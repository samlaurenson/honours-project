using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices.WindowsRuntime;
using System.Text;
using HonoursProject.behaviours;

namespace HonoursProject
{
    //! Singleton that will store data required for the model and data generated by the model.
    public class DataStore
    {
        private static DataStore _instance; /*!< Stores the instance of the singleton. */
        private List<HouseAgent> _houseAgents = new List<HouseAgent>(); /*!< List of all the house agents in the model. */
        private Dictionary<int, Dictionary<int, List<List<List<double>>>>> _simulations = new Dictionary<int, Dictionary<int, List<List<List<double>>>>>();
        private double randomStart;
        private double optimalStart;
        private List<List<double>> _endOfDaySatisfactions = new List<List<double>>(); /*!< List that stores the end of day satisfactions of agents for each day */
        private List<int> _availableSlots = new List<int>(); /*!< List of available slots that can be allocated to agents. */
        private static readonly Random _random = new Random(); /*!< Environment random. */
        [ThreadStatic] private static Random _local; //Creating a thread safe random. Using same instance of random on multiple threads can cause it to break and always return 0
        private List<List<double>> bucketedDemandCurves;  /*!< List of bucketed demand curves. Used to generate allocated and requested slots for agents. */
        private List<double> totalDemandValues; /*!< List of total demand values. Used to generate allocated and requested slots for agents. */
        private Dictionary<string, int> _globalFavoursGiven = new Dictionary<string, int>(); /*! Dictionary of agents and the number of favours they have given */
        private Dictionary<string, int> _globalFavoursOwed = new Dictionary<string, int>(); /*! Dictionary of agents and the number of favours they owe */

        //! Constructor for DataStore.
        private DataStore() {}

        //! Method that will return the instance of the DataStore.
        /*!
          If there has not been an instance created, then an instance of DataStore will be made.
         */
        public static DataStore Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new DataStore();
                }

                return _instance;
            }
        }

        //! Getter and setter for global favours given dictionary.
        public Dictionary<string, int> GlobalFavoursGiven
        {
            get { return _globalFavoursGiven; }
            set { _globalFavoursGiven = value; }
        }

        //! Getter and setter for global favours owed dictionary.
        public Dictionary<string, int> GlobalFavoursOwed
        {
            get { return _globalFavoursOwed; }
            set { _globalFavoursOwed = value; }
        }

        //! Getter and setter for list of house agents.
        public List<HouseAgent> HouseAgents
        {
            get { return _houseAgents; }
            set { _houseAgents = value; }
        }

        //! Getter and setter for list of available slots.
        public List<int> AvailableSlots
        {
            get { return _availableSlots; }
            set { _availableSlots = value; }
        }

        //! Getter and setter for the environment random variable.
        public Random EnvironmentRandom
        {
            get
            {
                if (_local == null)
                {
                    int seed;
                    lock (_random)
                    {
                        seed = _random.Next();
                    }
                    _local = new Random(seed);
                }
                return _local;
            }
        }

        //! Getter and setter for list of total demand values.
        public List<double> TotalDemand
        {
            get { return totalDemandValues; }
            set { totalDemandValues = value; }
        }

        //! Getter and setter for list of bucketed demand curves.
        public List<List<double>> BucketedDemandCurve
        {
            get { return bucketedDemandCurves; }
            set { bucketedDemandCurves = value; }
        }

        //! Getter and setter for end of day satisfaction list.
        public List<List<double>> EndOfDaySatisfaction
        {
            get { return _endOfDaySatisfactions; }
            set { _endOfDaySatisfactions = value; }
        }

        public Dictionary<int, Dictionary<int, List<List<List<double>>>>> SimulationData
        {
            get { return _simulations; }
            set { _simulations = value; }
        }

        //! Function that will calculate the satisfactions of agents after their allocation of slots (before exchanges begin) and the optimal satisfaction that can be obtained with the slots present in the environment.
        public void addStartOfDaySatisfactions()
        {
            randomStart = 0.0;
            optimalStart = 0.0;
            randomStart = averageAgentSatisfaction();
            optimalStart = optimumAgentSatisfaction();
        }

        //! Function that will be used to calculate the end of day satisfaction of agents.
        /*!
         Involves the calculation of - average agent satisfaction, optimum agent satisfaction, selfish agent satisfaction, elfish agent satisfaction variance, social agent satisfaction, social agent satisfaction variance
         \param day The day the satisfactions are being calculated for.
         */
        public void CalculateEndOfDaySatisfactions(int day)
        {
            //_endOfDaySatisfactions.Clear();
            List<double> satisfactions = new List<double>();


            satisfactions.Add(randomStart);
            satisfactions.Add(optimalStart);

            randomStart = 0;
            optimalStart = 0;

            var socialAgents = HouseAgents.Where(agent => agent.Behaviour is SocialBehaviour).ToList();
            var selfishAgents = HouseAgents.Where(agent => agent.Behaviour is SelfishBehaviour).ToList();


            //Not using loop to go over agent type calculations to avoid behaviours getting mixed when generating output file 
            //This could be what was causing the selfish and social behaviours to have such a strong correlation and why the difference was only
            //visible on graphs which only ran 1 instance of the model

            //Adding average satisfaction of each agent type to list
            satisfactions.Add(calculateSatisfactionForAgentTypes(selfishAgents));

            //Getting the average variance for each agent type
            satisfactions.Add(endOfDaySatisfactionStandardDeviation(selfishAgents));


            //Adding average satisfaction of each agent type to list
            satisfactions.Add(calculateSatisfactionForAgentTypes(socialAgents));

            //Getting the average variance for each agent type
            satisfactions.Add(endOfDaySatisfactionStandardDeviation(socialAgents));

            //First 2 elements in list will be the average and optimum agent satisfactions
            //After the first 2 elements, then elements will be the average satisfaction for agent type followed by average variance for agent type
            //And will follow this pattern for each agent type
            //e.g. 0 -> average agent satisfaction, 1 -> optimum agent satisfaction,
            // 2 -> Selfish agent satisfaction, 3 -> selfish agent satisfaction variance,
            // 4 -> Social agent satisfaction, 5 -> social agent satisfaction variance, and so on...
            _endOfDaySatisfactions.Add(satisfactions);
        }

        //! Function that will be used to calculate the average agent satisfaction.
        /*!
         \return Average agent satisfaction.
         */
        private double averageAgentSatisfaction()
        {
            List<double> agentSatisfactions = new List<double>();

            //Getting satisfaction for each agent in order to get the average satisfaction
            foreach (var agent in HouseAgents)
            {
                agentSatisfactions.Add(agent.CalculateSatisfaction(null));
            }

            return agentSatisfactions.Count > 0 ? agentSatisfactions.Average() : 0.0;
        }

        //! Function that will calculate the optimum agent satisfaction.
        /*!
         Calculates the optimum average satisfaction that could be obtained for all agents based on requests and allocations
        \return Optimum agent satisfaction.
         */
        private double optimumAgentSatisfaction()
        {
            List<int> allRequestedSlots = new List<int>();
            List<int> allAllocatedSlots = new List<int>();

            foreach (var agent in HouseAgents)
            {
                allRequestedSlots.AddRange(agent.RequestedSlots);
                allAllocatedSlots.AddRange(agent.AllocatedSlots);
            }

            //Stores number of slots that could potentially be fulfilled with perfect trading
            double satisfiedSlots = 0;

            //Storing total number of slot requests by all agents
            double totalSlots = allRequestedSlots.Count;

            foreach (int slot in allRequestedSlots)
            {
                if(allAllocatedSlots.Contains(slot))
                {
                    //For each request - if request has been allocated to any agent then increase number of satisfied slots
                    satisfiedSlots++;

                    //Remove slot from the list of all allocated slots so not slots can be allocated more than once
                    allAllocatedSlots.Remove(slot);
                }
            }

            return satisfiedSlots / totalSlots;
        }

        //! Function that will calculate the average agent satisfaction for each agent type.
        /*!
         \param List of house agents of a behaviour type (e.g. selfish or social).
         \return Average agent satisfaction for type.
         */
        private double calculateSatisfactionForAgentTypes(List<HouseAgent> agents)
        {
            //double satisfaction = 0.0;
            List<double> satisfaction = new List<double>();

            foreach (var agent in agents)
            {
                satisfaction.Add(agent.CalculateSatisfaction(null));
            }

            return satisfaction.Count > 0 ? satisfaction.Average() : 0.0;
        }

        //! Function that will calculate the end of day satisfaction standard deviation.
        /*!
         \param List of house agents of a behaviour type (e.g. selfish or social).
         \return Average variance of satisfaction for agent behaviour type.
         */
        private double endOfDaySatisfactionStandardDeviation(List<HouseAgent> agents)
        {
            double sumDiffsSquared = 0.0;
            int groupSize = 0;
            double averageSatisfaction = calculateSatisfactionForAgentTypes(agents);

            foreach (var agent in agents)
            {
                double diff = agent.CalculateSatisfaction(null) - averageSatisfaction;
                diff *= diff;
                sumDiffsSquared += diff;
                groupSize++;
            }

            double populationVariance = sumDiffsSquared / (double)groupSize;

            if (Double.IsNaN(Math.Sqrt(populationVariance)))
            {
                return 0.0;
            }
            return Math.Sqrt(populationVariance);
        }
    }
}
