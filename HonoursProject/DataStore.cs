using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices.WindowsRuntime;
using System.Text;
using HonoursProject.behaviours;

namespace HonoursProject
{
    //! Singleton that will store data required for the model and data generated by the model.
    public class DataStore
    {
        private static DataStore _instance; /*!< Stores the instance of the singleton. */
        private List<HouseAgent> _houseAgents = new List<HouseAgent>(); /*!< List of all the house agents in the model. */

        private Dictionary<int, List<List<List<double>>>> _simulations = new Dictionary<int, List<List<List<double>>>>(); /*!< Dictionary of data which contains 
                                                                                                                           * - Data for every evolving agent value in list of evolving agents
                                                                                                                           * - Data for every model executed for each evolving agent execution
                                                                                                                           * - Data for each day in the model*/
        private double randomStart;
        private double optimalStart;

        private List<List<double>> _endOfDaySatisfactions = new List<List<double>>(); /*!< List that stores the end of day satisfactions of agents for each day */

        private List<int> _availableSlots = new List<int>(); /*!< List of available slots that can be allocated to agents. */

        private static readonly Random _random = new Random(); /*!< Environment random. */
        [ThreadStatic] private static Random _local; //Creating a thread safe random. Using same instance of random on multiple threads can cause it to break and always return 0

        private List<List<double>> bucketedDemandCurves;  /*!< List of bucketed demand curves. Used to generate allocated and requested slots for agents. */
        private List<double> totalDemandValues; /*!< List of total demand values. Used to generate allocated and requested slots for agents. */

        //! Constructor for DataStore.
        private DataStore() {}

        //! Method that will return the instance of the DataStore.
        /*!
          If there has not been an instance created, then an instance of DataStore will be made.
         */
        public static DataStore Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new DataStore();
                }

                return _instance;
            }
        }

        //! Getter and setter for list of house agents.
        public List<HouseAgent> HouseAgents
        {
            get { return _houseAgents; }
            set { _houseAgents = value; }
        }

        //! Getter and setter for list of available slots.
        public List<int> AvailableSlots
        {
            get { return _availableSlots; }
            set { _availableSlots = value; }
        }

        //! Getter and setter for the environment random variable.
        public Random EnvironmentRandom
        {
            get
            {
                if (_local == null)
                {
                    int seed;
                    lock (_random)
                    {
                        seed = _random.Next();
                    }
                    _local = new Random(seed);
                }
                return _local;
            }
        }

        //! Getter and setter for list of total demand values.
        public List<double> TotalDemand
        {
            get { return totalDemandValues; }
            set { totalDemandValues = value; }
        }

        //! Getter and setter for list of bucketed demand curves.
        public List<List<double>> BucketedDemandCurve
        {
            get { return bucketedDemandCurves; }
            set { bucketedDemandCurves = value; }
        }

        //! Getter and setter for end of day satisfaction list.
        public List<List<double>> EndOfDaySatisfaction
        {
            get { return _endOfDaySatisfactions; }
            set { _endOfDaySatisfactions = value; }
        }

        //! Getter and setter for simulation data.
        public Dictionary<int, List<List<List<double>>>> SimulationData
        {
            get { return _simulations; }
            set { _simulations = value; }
        }

        /*public int GetRandomInteger(int max)
        {
            lock (_random)
            {
                return _random.Next(max);
            }
        }

        public double GetRandomDouble()
        {
            lock (_random)
            {
                return _random.NextDouble();
            }
        }*/

        public void addStartOfDaySatisfactions()
        {
            randomStart = 0.0;
            optimalStart = 0.0;
            randomStart = averageAgentSatisfaction();
            optimalStart = optimumAgentSatisfaction();
        }

        //! Function that will be used to calculate the end of day satisfaction of agents.
        /*!
         Involves the calculation of - average agent satisfaction, optimum agent satisfaction, selfish agent satisfaction, elfish agent satisfaction variance, social agent satisfaction, social agent satisfaction variance
         \param day The day the satisfactions are being calculated for.
         */
        public void CalculateEndOfDaySatisfactions(int day)
        {
            //_endOfDaySatisfactions.Clear();
            List<double> satisfactions = new List<double>();

            //satisfactions.Add(averageAgentSatisfaction());
            //satisfactions.Add(optimumAgentSatisfaction());
            satisfactions.Add(randomStart);
            satisfactions.Add(optimalStart);

            randomStart = 0;
            optimalStart = 0;

            var socialAgents = HouseAgents.Where(agent => agent.Behaviour is SocialBehaviour).ToList();
            var selfishAgents = HouseAgents.Where(agent => agent.Behaviour is SelfishBehaviour).ToList();

            //Calculating average satisfaction and variance for each agent type
            /*foreach (var type in agentTypes)
            {
                //Adding average satisfaction of each agent type to list
                satisfactions.Add(calculateSatisfactionForAgentTypes(type.ToList()));

                //Getting the average variance for each agent type
                satisfactions.Add(endOfDaySatisfactionStandardDeviation(type.ToList()));
            }*/


            //Not using loop to go over agent type calculations to avoid behaviours getting mixed when generating output file 
            //This could be what was causing the selfish and social behaviours to have such a strong correlation and why the difference was only
            //visible on graphs which only ran 1 instance of the model

            //Adding average satisfaction of each agent type to list
            satisfactions.Add(calculateSatisfactionForAgentTypes(selfishAgents));

            //Getting the average variance for each agent type
            satisfactions.Add(endOfDaySatisfactionStandardDeviation(selfishAgents));


            //Adding average satisfaction of each agent type to list
            satisfactions.Add(calculateSatisfactionForAgentTypes(socialAgents));

            //Getting the average variance for each agent type
            satisfactions.Add(endOfDaySatisfactionStandardDeviation(socialAgents));

            //First 2 elements in list will be the average and optimum agent satisfactions
            //After the first 2 elements, then elements will be the average satisfaction for agent type followed by average variance for agent type
            //And will follow this pattern for each agent type
            //e.g. 0 -> average agent satisfaction, 1 -> optimum agent satisfaction,
            // 2 -> Selfish agent satisfaction, 3 -> selfish agent satisfaction variance,
            // 4 -> Social agent satisfaction, 5 -> social agent satisfaction variance, and so on...
            _endOfDaySatisfactions.Add(satisfactions);
        }

        //! Function that will be used to calculate the average agent satisfaction.
        /*!
         \return Average agent satisfaction.
         */
        private double averageAgentSatisfaction()
        {
            List<double> agentSatisfactions = new List<double>();

            //Getting satisfaction for each agent in order to get the average satisfaction
            foreach (var agent in HouseAgents)
            {
                agentSatisfactions.Add(agent.CalculateSatisfaction(null));
            }

            return agentSatisfactions.Count > 0 ? agentSatisfactions.Average() : 0.0;
        }

        //! Function that will calculate the optimum agent satisfaction.
        /*!
         Calculates the optimum average satisfaction that could be obtained for all agents based on requests and allocations
        \return Optimum agent satisfaction.
         */
        private double optimumAgentSatisfaction()
        {
            List<int> allRequestedSlots = new List<int>();
            List<int> allAllocatedSlots = new List<int>();

            foreach (var agent in HouseAgents)
            {
                //agent.RequestedSlots.ForEach(x => allRequestedSlots.Add(x));
                //agent.AllocatedSlots.ForEach(x => allAllocatedSlots.Add(x));
                allRequestedSlots.AddRange(agent.RequestedSlots);
                allAllocatedSlots.AddRange(agent.AllocatedSlots);
            }

            //Stores number of slots that could potentially be fulfilled with perfect trading
            double satisfiedSlots = 0;

            //Storing total number of slot requests by all agents
            double totalSlots = allRequestedSlots.Count;

            foreach (int slot in allRequestedSlots)
            {
                if(allAllocatedSlots.Contains(slot))
                {
                    //For each request - if request has been allocated to any agent then increase number of satisfied slots
                    satisfiedSlots++;

                    //Remove slot from the list of all allocated slots so not slots can be allocated more than once
                    allAllocatedSlots.Remove(slot);
                }
            }

            return satisfiedSlots / totalSlots;
        }

        //! Function that will calculate the average agent satisfaction for each agent type.
        /*!
         \param List of house agents of a behaviour type (e.g. selfish or social).
         \return Average agent satisfaction for type.
         */
        private double calculateSatisfactionForAgentTypes(List<HouseAgent> agents)
        {
            //double satisfaction = 0.0;
            List<double> satisfaction = new List<double>();

            foreach (var agent in agents)
            {
                satisfaction.Add(agent.CalculateSatisfaction(null));
            }

            return satisfaction.Count > 0 ? satisfaction.Average() : 0.0;
        }

        //! Function that will calculate the end of day satisfaction standard deviation.
        /*!
         \param List of house agents of a behaviour type (e.g. selfish or social).
         \return Average variance of satisfaction for agent behaviour type.
         */
        private double endOfDaySatisfactionStandardDeviation(List<HouseAgent> agents)
        {
            double sumDiffsSquared = 0.0;
            int groupSize = 0;
            double averageSatisfaction = calculateSatisfactionForAgentTypes(agents);

            foreach (var agent in agents)
            {
                double diff = agent.CalculateSatisfaction(null) - averageSatisfaction;
                diff *= diff;
                sumDiffsSquared += diff;
                groupSize++;
            }

            double populationVariance = sumDiffsSquared / (double)groupSize;

            if (Double.IsNaN(Math.Sqrt(populationVariance)))
            {
                return 0.0;
            }
            return Math.Sqrt(populationVariance);
        }
    }
}
